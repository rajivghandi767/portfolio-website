pipeline {
    agent any

    // 1. Scheduled Trigger (0330Hrs Daily)
    triggers {
        cron('30 3 * * *')
    }

    // 2. Rollback Parameter
    parameters {
        string(name: 'TAG_TO_DEPLOY', defaultValue: 'latest', description: 'Tag to deploy (e.g. "latest" or build number "45")')
    }

    environment {
        // --- CONFIGURATION ---
        SSH_CRED_ID      = "raspberry-pi-ssh"
        VAULT_CRED_ID    = "vault-portfolio-approle"
        REGISTRY_CRED_ID = "github-packages-pat"
        VAULT_ADDR       = 'http://vault:8200'
        
        DEPLOY_USER = "dietpi"
        DEPLOY_HOST = "10.100.10.5"
        DEPLOY_DIR  = "/opt/homelab-iac/services/apps/portfolio-website"

        // Image names for notifications
        IMAGE_BACKEND  = "rajivghandi767/portfolio-backend"
        IMAGE_FRONTEND = "rajivghandi767/portfolio-frontend"
        IMAGE_NGINX    = "rajivghandi767/portfolio-nginx"

        // --- NOTIFICATIONS ---
        // Separate webhook for Jenkins status (Stored in Jenkins Credentials)
        JENKINS_DISCORD_WEBHOOK = credentials('jenkins-discord-webhook')
    }

    stages {
        stage('Deploy Configuration') {
            steps {
                checkout scm

                // A. Fetch App Secrets from Vault
                withVault(configuration: [vaultUrl: "${VAULT_ADDR}", vaultCredentialId: "${VAULT_CRED_ID}", engineVersion: 2], 
                vaultSecrets: [[path: 'secret/portfolio-prod', secretValues: [
                    [envVar: 'DJANGO_SECRET_KEY', vaultKey: 'DJANGO_SECRET_KEY'],
                    [envVar: 'ALLOWED_HOSTS', vaultKey: 'ALLOWED_HOSTS'],
                    [envVar: 'CSRF_TRUSTED_ORIGINS', vaultKey: 'CSRF_TRUSTED_ORIGINS'],
                    [envVar: 'POSTGRES_HOST', vaultKey: 'POSTGRES_HOST'],
                    [envVar: 'POSTGRES_PORT', vaultKey: 'POSTGRES_PORT'],
                    [envVar: 'POSTGRES_USER', vaultKey: 'POSTGRES_USER'],
                    [envVar: 'POSTGRES_PASSWORD', vaultKey: 'POSTGRES_PASSWORD'],
                    [envVar: 'POSTGRES_DB', vaultKey: 'POSTGRES_DB'],
                    [envVar: 'ADMIN_URL', vaultKey: 'ADMIN_URL'],
                    [envVar: 'DISCORD_WEBHOOK_URL', vaultKey: 'DISCORD_WEBHOOK_URL'], // App's own webhook
                ]]]) {
                    
                    // B. Fetch Registry Credentials
                    withCredentials([usernamePassword(credentialsId: REGISTRY_CRED_ID, usernameVariable: 'REGISTRY_USER', passwordVariable: 'REGISTRY_PASS')]) {
                        script {
                            // C. Generate .env file LOCALLY
                            def envContent = """
                                IMAGE_TAG='${params.TAG_TO_DEPLOY}'
                                DJANGO_SECRET_KEY='${DJANGO_SECRET_KEY}'
                                ALLOWED_HOSTS='${ALLOWED_HOSTS}'
                                CSRF_TRUSTED_ORIGINS='${CSRF_TRUSTED_ORIGINS}'
                                POSTGRES_HOST='${POSTGRES_HOST}'
                                POSTGRES_PORT='${POSTGRES_PORT}'
                                POSTGRES_USER='${POSTGRES_USER}'
                                POSTGRES_PASSWORD='${POSTGRES_PASSWORD}'
                                POSTGRES_DB='${POSTGRES_DB}'
                                ADMIN_URL='${ADMIN_URL}'
                                DISCORD_WEBHOOK_URL='${DISCORD_WEBHOOK_URL}'
                            """.stripIndent()
                            
                            writeFile file: '.env.prod', text: envContent

                            sshagent([SSH_CRED_ID]) {
                                // D. Pre-flight Security
                                sh """
                                    mkdir -p ~/.ssh
                                    ssh-keyscan -H ${DEPLOY_HOST} >> ~/.ssh/known_hosts || true
                                """

                                // E. Transfer files
                                sh """
                                    echo "üì¶ Syncing files to ${DEPLOY_HOST}..."
                                    scp docker-compose.yml ${DEPLOY_USER}@${DEPLOY_HOST}:${DEPLOY_DIR}/docker-compose.yml
                                    scp .env.prod ${DEPLOY_USER}@${DEPLOY_HOST}:${DEPLOY_DIR}/.env
                                """

                                // F. Remote Execution
                                
                                // STEP A: Secure Login
                                sh "echo \$REGISTRY_PASS | ssh ${DEPLOY_USER}@${DEPLOY_HOST} 'docker login ghcr.io -u ${REGISTRY_USER} --password-stdin'"

                                // STEP B: Check for Updates
                                // We pull first to see if there are changes. The login from Step A persists for this session.
                                def isManualDeploy = params.TAG_TO_DEPLOY != 'latest'
                                
                                def pullOutput = sh(script: """
                                    ssh ${DEPLOY_USER}@${DEPLOY_HOST} '
                                        cd ${DEPLOY_DIR}
                                        IMAGE_TAG=${params.TAG_TO_DEPLOY} docker compose pull 2>&1
                                    '
                                """, returnStdout: true).trim()
                                
                                echo "üîç Pull Status: \n${pullOutput}"

                                // STEP C: Conditional Deploy
                                if (isManualDeploy || pullOutput.contains("Downloaded") || pullOutput.contains("Pulled")) {
                                    echo "üöÄ Changes detected or Manual Rollback. Deploying..."
                                    
                                    sh """
                                        ssh ${DEPLOY_USER}@${DEPLOY_HOST} '
                                            cd ${DEPLOY_DIR}
                                            chmod 600 .env
                                            
                                            # Deploy with specific tag
                                            IMAGE_TAG=${params.TAG_TO_DEPLOY} docker compose up -d --remove-orphans
                                            
                                            # Cleanup
                                            docker image prune -f
                                        '
                                    """
                                    currentBuild.result = 'SUCCESS'
                                    env.DEPLOY_STATUS = "UPDATED"
                                } else {
                                    echo "üí§ No new images found. Skipping deploy."
                                    currentBuild.result = 'SUCCESS'
                                    env.DEPLOY_STATUS = "SKIPPED"
                                }
                                
                                // STEP D: Always Logout
                                sh "ssh ${DEPLOY_USER}@${DEPLOY_HOST} 'docker logout ghcr.io'"

                                // G. Cleanup Local Secrets
                                sh "rm .env.prod"
                            }
                        }
                    }
                }
            }
        }
    }

    // 3. Discord Notifications
    post {
        success {
            script {
                if (env.DEPLOY_STATUS == "UPDATED") {
                    def deployMessage = """
:unicorn: **Portfolio Website Update Deployed**
**:new: New Version Live:**
‚Ä¢ **Tag:** ${params.TAG_TO_DEPLOY}
‚Ä¢ **Backend:** ${IMAGE_BACKEND}
‚Ä¢ **Frontend:** ${IMAGE_FRONTEND}
‚Ä¢ **Nginx:** ${IMAGE_NGINX}

:bar_chart: **Status:** Healthy
:clock4: **Time:** ${java.time.LocalDateTime.now()}
"""
                    discordSend description: deployMessage, result: currentBuild.currentResult, title: "üöÄ Deployment Successful", webhookURL: env.JENKINS_DISCORD_WEBHOOK, color: '#00ff00'
                } 
                else if (env.DEPLOY_STATUS == "SKIPPED") {
                    def skipMessage = """
:shield: **Portfolio Website Up to Date**
No new Docker images found for tag: **${params.TAG_TO_DEPLOY}**.
Running services remain unchanged.

:clock4: **Time:** ${java.time.LocalDateTime.now()}
"""
                    discordSend description: skipMessage, result: currentBuild.currentResult, title: "‚úÖ Check Complete: No Changes", webhookURL: env.JENKINS_DISCORD_WEBHOOK, color: '#3498db'
                }
            }
        }
        failure {
            script {
                def failMessage = """
:x: **Portfolio Website Deployment Failed**
**:warning: Error Details:**
Check Jenkins logs for build #${BUILD_NUMBER}.

:wrench: **Action Required:** Manual intervention needed.
"""
                discordSend description: failMessage, result: currentBuild.currentResult, title: "üö® Deployment Alert", webhookURL: env.JENKINS_DISCORD_WEBHOOK, color: '#ff0000'
            }
        }
    }
}